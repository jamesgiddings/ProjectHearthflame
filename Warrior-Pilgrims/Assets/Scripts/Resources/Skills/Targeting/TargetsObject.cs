using GramophoneUtils.Characters;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

/// <summary>
/// A targets object to generated by skills which can target a single characters in variety of slots.
/// </summary>
public class TargetsObject : ITargets
{
    #region Attributes/Fields/Properties

    private int _currentCombinationIndex;
    private List<List<Character>> _characterCombinations;
    private ITargetToSlots _targetToSlots;
    private Character _originator;
    private CharacterOrder _playerCharacterOrder;
    private CharacterOrder _enemyCharacterOrder;

    #endregion

    #region Constructors

    private TargetsObject() { }

    public TargetsObject(ITargetToSlots targetToSlots, Character originator, CharacterOrder playerCharacterOrder, CharacterOrder enemyCharacterOrder)
    {
        _currentCombinationIndex = 0;
        _targetToSlots = targetToSlots;
        _originator = originator;
        _playerCharacterOrder = playerCharacterOrder;
        _enemyCharacterOrder = enemyCharacterOrder;
        _characterCombinations = GetAllCombinations(targetToSlots);
    }

    #endregion

    #region Callbacks
    #endregion

    #region Public Functions

    public List<Character> ChangeCurrentlyTargeted(Vector2 direction)
    {
        //Todo, here we have to assess the maximum number of characters in a particular target field, i.e. ally or opponent, and then cap the _currentCombinationINDEX at the lower of the two.


        Debug.Log("_characterCombinations.Count:" + _characterCombinations.Count);
        List<Character> currentlyTargeted = new List<Character>();
        switch (direction)
        {
            case Vector2 vector when (vector.y >= 0f && Math.Abs(vector.y) > Math.Abs(vector.x) || // move down
                    vector.x >= 0f && Math.Abs(vector.x) > Math.Abs(vector.y)): // move left
                _currentCombinationIndex++;
                if (_currentCombinationIndex < 0)
                {
                    _currentCombinationIndex = _characterCombinations.Count - 1;
                }
                if (_currentCombinationIndex > (_characterCombinations.Count - 1))
                {
                    _currentCombinationIndex = 0;
                }
                if (_currentCombinationIndex > -1 && _currentCombinationIndex < _characterCombinations.Count)
                {
                    currentlyTargeted = _characterCombinations[_currentCombinationIndex];
                }
                Debug.Log("_currentCombinationIndex:" + _currentCombinationIndex);
                break;
            case Vector2 vector when (vector.y <= 0f && Math.Abs(vector.y) > Math.Abs(vector.x) || // move up
                    vector.x <= 0f && Math.Abs(vector.x) > Math.Abs(vector.y)): // move right
                _currentCombinationIndex--;
                if (_currentCombinationIndex < 0)
                {
                    _currentCombinationIndex = _characterCombinations.Count - 1;
                }
                if (_currentCombinationIndex > (_characterCombinations.Count - 1))
                {
                    _currentCombinationIndex = 0;
                }
                if (_currentCombinationIndex > -1 && _currentCombinationIndex < _characterCombinations.Count)
                {
                    currentlyTargeted = _characterCombinations[_currentCombinationIndex];
                }
                Debug.Log("_currentCombinationIndex:" + _currentCombinationIndex);
                break;

        }
        return currentlyTargeted;
    }

    public List<Character> GetCurrentlyTargeted()
    {
        if (_characterCombinations == null || _characterCombinations.Count == 0) { return new List<Character>(); }
        return _characterCombinations[_currentCombinationIndex];
    }

    #endregion

    #region Protected Functions
    #endregion

    #region Private Functions

    private List<List<Character>> GetAllCombinations(ITargetToSlots targetToSlots)
    {
        List<List<Character>> combinations = new List<List<Character>>();

        List<TargetCombination> targetCombinations = targetToSlots.GetTargetCombinations();
        List<Character> opponentCharacters = _originator.IsPlayer ? _enemyCharacterOrder.GetCharacters().ToList() : _playerCharacterOrder.GetCharacters().ToList();
        List<Character> allyCharacters = !_originator.IsPlayer ? _enemyCharacterOrder.GetCharacters().ToList() : _playerCharacterOrder.GetCharacters().ToList();

        foreach (TargetCombination targetCombination in targetCombinations)
        {
            List<Character> chars = targetCombination.GetCombination(allyCharacters, opponentCharacters);
            Debug.Log("List of chars: ");
            chars.ForEach(x => Debug.Log(x.Name));

            List<Character> combination = targetCombination.GetCombination(allyCharacters, opponentCharacters);
            if (combination.Count > 0) // check there are actually characters there.
            {
                combinations.Add(combination);
            }
            
        }

        return combinations;
    }

    #endregion

    #region Inner Classes
    #endregion

}
