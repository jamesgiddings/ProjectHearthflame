using GramophoneUtils.Characters;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

/// <summary>
/// A targets object to generated by skills which can target a single characters in variety of slots.
/// </summary>
public class TargetsObject : ITargets
{
    #region Attributes/Fields/Properties

    private int _currentCombinationIndex;
    private List<List<Character>> _characterCombinations;
    private ITargetToSlots _targetToSlots;
    private Character _originator;
    private CharacterOrder _playerCharacterOrder;
    private CharacterOrder _enemyCharacterOrder;

    #endregion

    #region Constructors

    private TargetsObject() { }

    public TargetsObject(ITargetToSlots targetToSlots, Character originator, CharacterOrder playerCharacterOrder, CharacterOrder enemyCharacterOrder)
    {
        _currentCombinationIndex = 0;
        _targetToSlots = targetToSlots;
        _originator = originator;
        _playerCharacterOrder = playerCharacterOrder;
        _enemyCharacterOrder = enemyCharacterOrder;
        _characterCombinations = GetAllCombinations(targetToSlots);
    }

    #endregion

    #region Callbacks
    #endregion

    #region Public Functions

    public List<Character> ChangeCurrentlyTargeted(Vector2 direction)
    {
        //Todo, here we have to assess the maximum number of characters in a particular target field, i.e. ally or opponent, and then cap the _currentCombinationINDEX at the lower of the two.


        Debug.Log("_characterCombinations.Count:" + _characterCombinations.Count);
        List<Character> currentlyTargeted = new List<Character>();
        switch (direction)
        {
            case Vector2 vector when (vector.y >= 0f && Math.Abs(vector.y) > Math.Abs(vector.x) || // move down
                    vector.x >= 0f && Math.Abs(vector.x) > Math.Abs(vector.y)): // move left
                _currentCombinationIndex++;
                if (_currentCombinationIndex < 0)
                {
                    _currentCombinationIndex = _characterCombinations.Count - 1;
                }
                if (_currentCombinationIndex > (_characterCombinations.Count - 1))
                {
                    _currentCombinationIndex = 0;
                }
                if (_currentCombinationIndex > -1 && _currentCombinationIndex < _characterCombinations.Count)
                {
                    currentlyTargeted = _characterCombinations[_currentCombinationIndex];
                }
                Debug.Log("_currentCombinationIndex:" + _currentCombinationIndex);
                break;
            case Vector2 vector when (vector.y <= 0f && Math.Abs(vector.y) > Math.Abs(vector.x) || // move up
                    vector.x <= 0f && Math.Abs(vector.x) > Math.Abs(vector.y)): // move right
                _currentCombinationIndex--;
                if (_currentCombinationIndex < 0)
                {
                    _currentCombinationIndex = _characterCombinations.Count - 1;
                }
                if (_currentCombinationIndex > (_characterCombinations.Count - 1))
                {
                    _currentCombinationIndex = 0;
                }
                if (_currentCombinationIndex > -1 && _currentCombinationIndex < _characterCombinations.Count)
                {
                    currentlyTargeted = _characterCombinations[_currentCombinationIndex];
                }
                Debug.Log("_currentCombinationIndex:" + _currentCombinationIndex);
                break;

        }
        return currentlyTargeted;
    }

    public List<Character> GetCurrentlyTargeted()
    {
        if (_characterCombinations == null || _characterCombinations.Count == 0) { return new List<Character>(); }
        return _characterCombinations[_currentCombinationIndex];
    }

    #endregion

    #region Protected Functions
    #endregion

    #region Private Functions

    private List<List<Character>> GetAllCombinations(ITargetToSlots targetToSlots)
    {
        List<List<Character>> combinations = new List<List<Character>>();

        List<TargetCombination> targetCombinations = targetToSlots.GetTargetCombinations();
        CharacterOrder opponentCharacterOrder = _originator.IsPlayer ? _enemyCharacterOrder : _playerCharacterOrder;
        CharacterOrder allyCharacterOrder = _originator.IsPlayer ? _playerCharacterOrder : _enemyCharacterOrder;

        foreach (TargetCombination targetCombination in targetCombinations)
        {
            List<Character> combination = targetCombination.GetCombination(allyCharacterOrder, opponentCharacterOrder);
            if (combination.Count > 0) // check there are actually characters there.
            {
                combinations.Add(combination); // TODO, we are adding this to a hashset, but it isn't rejecting the duplicate if it targets a large character twice.
            }
            
        }

        return combinations.ToList();
    }

    #endregion

    #region Inner Classes

    class ListEqCompare : IEqualityComparer<List<Character>>
    {
        public bool Equals(List<Character> x, List<Character> y)
        {
            if (x.Count != y.Count)
                return false;
            for (int i = 0; i < x.Count; i++)
            {
                if (x[i] != y[i])
                    return false;
            }
            return true;
        }

        public int GetHashCode(List<Character> obj)
        {
            int hash = 0;
            foreach (Character character in obj)
                hash = hash ^ EqualityComparer<Character>.Default.GetHashCode(character);

            return hash;
        }
    }

    #endregion

}
